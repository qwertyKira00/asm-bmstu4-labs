#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
 #define LEN 256
// Ассемблерные вставки используются для «насильственного»
// размещения в Си-программах ассемблерного
// кода, явно заданного программистом.
int asm_strlen(char *str)
{
    int str_len = 0;
 
    // Директива .intel_syntax меняет синтаксис AT&T на синтаксис Intel; необходимо
    // дополнительно указывать смену синтаксиса для операндов инструкций, noprefix, что позволит
    // писать код в более близком к диалекту nasm виде, не используя при записи имен регистров префикс %.
 
    asm(".intel_syntax noprefix\n\t" // директива .intel_syntax
        "mov ecx, 0xFFFF\n\t"
        "lea rdi, [%1]\n\t" // команда LEA выполняет вычисление адреса второго операнда и записывание его в первый операнд
        "mov al, 0\n\t"
        "repne scasb\n\t"
        "mov eax, 0xFFFF\n\t"
        "sub eax, ecx\n\t"
        "dec eax\n\t" 
        "mov %0, eax\n\t"
        : "=r"(str_len)                       // список выходных параметров. (r == register (Т.е. записать в регистр))
        : "r"(str)                           // список входных параметров.
        : "eax", "al", "ecx", "rdi");       // список разрушаемых регистров.
 
    // SCASB - Сравнить байт по адресу ES:(E)DI с AL 
    // Результат отбрасывается, устанавливаются только флаги
    // Операнд-источник адресуется регистровой парой ES:(E)DI
    // После завершения сравнения индексный регистр (E)DI автоматически изменяется
    
    // REPNE SCASB - Найти байт равный AL в блоке из (E)CX байт по адресу ES:(E)DI
    // Префиксы REP (F3h), REPE (F3h) и REPNE (F2h) применяются со строковыми операциями. 
    // Каждый префикс заставляет строковую команду, которая следует за ним, повторяться 
    // указанное в регистре счетчике (E)CX количество раз или,
    // кроме этого, (для префиксов REPE и REPNE) пока не встретится указанное условие во флаге ZF. 
 
    // Если требуется что бы операнд был размещен в
    // Каком - либо регистре общего назначения то задаем символом r.
    // Если требуется, что бы операнд был размещен в памяти, вместо
    // символа r следует использовать символ m.
 
    return str_len;
}
 
int main()
{
    char string[LEN] = "Hello, world! Assembler";
    int str_len = asm_strlen(string);
    
    printf("String length:\nC (strlen() function): %ld\nASM: %d\n", strlen(string), str_len);

    char new_string[LEN];

    str_copy(string + 4, string, str_len);
    
    printf("First string = %s\nSecond string (copy) = %s\n", string, new_string);

    // В 64-разрядном режиме сегментные регистры CS, DS, ES и SS в формировании линейного (непрерывного)
    // адреса не участвуют, поскольку сегментация в этом режиме не поддерживается.
}